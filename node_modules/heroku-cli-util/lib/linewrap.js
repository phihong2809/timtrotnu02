// code is from https://github.com/AnAppAMonth/linewrap

// Presets
var presetMap = {
  'html': {
    skipScheme: 'html',
    lineBreakScheme: 'html',
    whitespace: 'collapse'
  }
}

// lineBreak Schemes
var brPat = /<\s*br(?:[\s/]*|\s[^>]*)>/gi
var lineBreakSchemeMap = {
  'unix': [/\n/g, '\n'],
  'dos': [/\r\n/g, '\r\n'],
  'mac': [/\r/g, '\r'],
  'html': [brPat, '<br>'],
  'xhtml': [brPat, '<br/>']
}

// skip Schemes
var skipSchemeMap = {
  'ansi-color': /\x1B\[[^m]*m/g,
  'html': /<[^>]*>/g,
  'bbcode': /\[[^]]*\]/g
}

var modeMap = {
  'soft': 1,
  'hard': 1
}

var wsMap = {
  'collapse': 1,
  'default': 1,
  'line': 1,
  'all': 1
}

var rlbMap = {
  'all': 1,
  'multi': 1,
  'none': 1
}
var rlbSMPat = /([sm])(\d+)/

var escapePat = /[-/\\^$*+?.()|[\]{}]/g
function escapeRegExp (s) {
  return s.replace(escapePat, '\\$&')
}

var linewrap = module.exports = function (start, stop, params) {
  if (typeof start === 'object') {
    params = start
    start = params.start
    stop = params.stop
  }

  if (typeof stop === 'object') {
    params = stop
    start = start || params.start
    stop = undefined
  }

  if (!stop) {
    stop = start
    start = 0
  }

  if (!params) { params = {}; }
  // Supported options and default values.
  var preset,
    mode = 'soft',
    whitespace = 'default',
    tabWidth = 4,
    skip, skipScheme, lineBreak, lineBreakScheme,
    respectLineBreaks = 'all',
    respectNum,
    preservedLineIndent,
    wrapLineIndent, wrapLineIndentBase

  var skipPat
  var lineBreakPat, lineBreakStr
  var multiLineBreakPat
  var preservedLinePrefix = ''
  var wrapLineIndentPat, wrapLineInitPrefix = ''
  var tabRepl
  var item, flags
  var i

  // First process presets, because these settings can be overwritten later.
  preset = params.preset
  if (preset) {
    if (!(preset instanceof Array)) {
      preset = [preset]
    }
    for (i = 0; i < preset.length; i++) {
      item = presetMap[preset[i]]
      if (item) {
        if (item.mode) {
          mode = item.mode
        }
        if (item.whitespace) {
          whitespace = item.whitespace
        }
        if (item.tabWidth !== undefined) {
          tabWidth = item.tabWidth
        }
        if (item.skip) {
          skip = item.skip
        }
        if (item.skipScheme) {
          skipScheme = item.skipScheme
        }
        if (item.lineBreak) {
          lineBreak = item.lineBreak
        }
        if (item.lineBreakScheme) {
          lineBreakScheme = item.lineBreakScheme
        }
        if (item.respectLineBreaks) {
          respectLineBreaks = item.respectLineBreaks
        }
        if (item.preservedLineIndent !== undefined) {
          preservedLineIndent = item.preservedLineIndent
        }
        if (item.wrapLineIndent !== undefined) {
          wrapLineIndent = item.wrapLineIndent
        }
        if (item.wrapLineIndentBase) {
          wrapLineIndentBase = item.wrapLineIndentBase
        }
      } else {
        throw new TypeError('preset must be one of "' + Object.keys(presetMap).join('", "') + '"')
      }
    }
  }

  if (params.mode) {
    if (modeMap[params.mode]) {
      mode = params.mode
    } else {
      throw new TypeError('mode must be one of "' + Object.keys(modeMap).join('", "') + '"')
    }
  }
  // Available options: 'collapse', 'default', 'line', and 'all'
  if (params.whitespace) {
    if (wsMap[params.whitespace]) {
      whitespace = params.whitespace
    } else {
      throw new TypeError('whitespace must be one of "' + Object.keys(wsMap).join('", "') + '"')
    }
  }

  if (params.tabWidth !== undefined) {
    if (parseInt(params.tabWidth, 10) >= 0) {
      tabWidth = parseInt(params.tabWidth, 10)
    } else {
      throw new TypeError('tabWidth must be a non-negative integer')
    }
  }
  tabRepl = new Array(tabWidth + 1).join(' ')

  // Available options: 'all', 'multi', 'm\d+', 's\d+', 'none'
  if (params.respectLineBreaks) {
    if (rlbMap[params.respectLineBreaks] || rlbSMPat.test(params.respectLineBreaks)) {
      respectLineBreaks = params.respectLineBreaks
    } else {
      throw new TypeError('respectLineBreaks must be one of "' + Object.keys(rlbMap).join('", "') +
        '", "m<num>", "s<num>"')
    }
  }
  // After these conversions, now we have 4 options in `respectLineBreaks`:
  // 'all', 'none', 'm' and 's'.
  // `respectNum` is applicable iff `respectLineBreaks` is either 'm' or 's'.
  if (respectLineBreaks === 'multi') {
    respectLineBreaks = 'm'
    respectNum = 2
  } else if (!rlbMap[respectLineBreaks]) {
    var match = rlbSMPat.exec(respectLineBreaks)
    respectLineBreaks = match[1]
    respectNum = parseInt(match[2], 10)
  }

  if (params.preservedLineIndent !== undefined) {
    if (parseInt(params.preservedLineIndent, 10) >= 0) {
      preservedLineIndent = parseInt(params.preservedLineIndent, 10)
    } else {
      throw new TypeError('preservedLineIndent must be a non-negative integer')
    }
  }

  if (preservedLineIndent > 0) {
    preservedLinePrefix = new Array(preservedLineIndent + 1).join(' ')
  }

  if (params.wrapLineIndent !== undefined) {
    if (!isNaN(parseInt(params.wrapLineIndent, 10))) {
      wrapLineIndent = parseInt(params.wrapLineIndent, 10)
    } else {
      throw new TypeError('wrapLineIndent must be an integer')
    }
  }
  if (params.wrapLineIndentBase) {
    wrapLineIndentBase = params.wrapLineIndentBase
  }

  if (wrapLineIndentBase) {
    if (wrapLineIndent === undefined) {
      throw new TypeError('wrapLineIndent must be specified when wrapLineIndentBase is specified')
    }
    if (wrapLineIndentBase instanceof RegExp) {
      wrapLineIndentPat = wrapLineIndentBase
    } else if (typeof wrapLineIndentBase === 'string') {
      wrapLineIndentPat = new RegExp(escapeRegExp(wrapLineIndentBase))
    } else {
      throw new TypeError('wrapLineIndentBase must be either a RegExp object or a string')
    }
  } else if (wrapLineIndent > 0) {
    wrapLineInitPrefix = new Array(wrapLineIndent + 1).join(' ')
  } else if (wrapLineIndent < 0) {
    throw new TypeError('wrapLineIndent must be non-negative when a base is not specified')
  }

  // NOTE: For the two RegExps `skipPat` and `lineBreakPat` that can be specified
  //       by the user:
  //       1. We require them to be "global", so we have to convert them to global
  //          if the user specifies a non-global regex.
  //       2. We cannot call `split()` on them, because they may or may not contain
  //          capturing parentheses which affect the output of `split()`.

  // Precedence: Regex = Str > Scheme
  if (params.skipScheme) {
    if (skipSchemeMap[params.skipScheme]) {
      skipScheme = params.skipScheme
    } else {
      throw new TypeError('skipScheme must be one of "' + Object.keys(skipSchemeMap).join('", "') + '"')
    }
  }
  if (params.skip) {
    skip = params.skip
  }

  if (skip) {
    if (skip instanceof RegExp) {
      skipPat = skip
      if (!skipPat.global) {
        flags = 'g'
        if (skipPat.ignoreCase) { flags += 'i'; }
        if (skipPat.multiline) { flags += 'm'; }
        skipPat = new RegExp(skipPat.source, flags)
      }
    } else if (typeof skip === 'string') {
